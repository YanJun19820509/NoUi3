// Effect Syntax Guide: https://docs.cocos.com/creator/manual/zh/shader/index.html

CCEffect %{
  techniques:
  - passes:
    - vert: vs:vert 
      frag: unlit-fs:frag
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none
      properties:
        atlas0: {value: default}
        atlas1: {value: default}
        atlas2: {value: default}
        atlas3: {value: default}
        atlas4: {value: default}
        atlas5: {value: default}
        atlas6: {value: default}
}%

CCProgram vs %{
  #include <./common-vs>
}%

CCProgram unlit-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/internal/embedded-alpha>
  #include <builtin/internal/alpha-test>
  #include <./common-fs>
  #include <./utils>

  uniform sampler2D atlas0;
  uniform sampler2D atlas1;
  uniform sampler2D atlas2;
  uniform sampler2D atlas3;
  uniform sampler2D atlas4;
  uniform sampler2D atlas5;
  uniform sampler2D atlas6;

  vec4 setTexture(int type, vec2 uv){
    //贴图纹理取值0
    if (type == 0){ 
      return texture(atlas0, uv);
    }

    //贴图纹理取值1
    else if (type == 1){ 
      return texture(atlas1, uv);
    }

    //贴图纹理取值2
    else if (type == 2){ 
      return texture(atlas2, uv);
    }

    //贴图纹理取值3
    else if (type == 3){ 
      return texture(atlas3, uv);
    }

    //贴图纹理取值4
    else if (type == 4){ 
      return texture(atlas4, uv);
    }

    //贴图纹理取值5
    else if (type == 5){ 
      return texture(atlas5, uv);
    }

    //贴图纹理取值6
    else if (type == 6){ 
      return texture(atlas6, uv);
    }
    return vec4(1, 1, 1, 1);
  }

  vec4 setEffect(float type, vec4 _color){
      //置灰
      if(type == 2.){ 
        _color = gray(_color);
      }
      
      //挖方孔
      if(type == 3.){ 
          vec2 uv = uv0;
          uv.y *= cc_screenSize.y / cc_screenSize.x;
          float x1 = floor(ext.x) / 100.;
          float y1 = fract(ext.x) * cc_screenSize.y / cc_screenSize.x;
          float x2 = floor(ext.y) / 100.;
          float y2 = fract(ext.y) * cc_screenSize.y / cc_screenSize.x;
          
          if(uv.x > x1 && uv.x < x2 && uv.y > y1 && uv.y < y2){
            _color.a = 0.;
          }
      }

      //挖圆孔
      if(type == 4.){ 
          vec2 uv = uv0;
          uv.y *= cc_screenSize.y / cc_screenSize.x;
          float x = floor(ext.x) / 100.;
          float y = fract(ext.x) * cc_screenSize.y / cc_screenSize.x;
          float r = ext.y;
          float dis = distance(uv, vec2(x,y));
          
          if(dis<=r){
            _color.a *= smoothstep(.8, 1., dis/r);
          }
      }

      //遮罩上色
      else if(type == 5.){
          _color = maskColor(_color);
      }

      //黑色遮罩上色
      else if(type == 6.){
          _color = blackMaskColor(_color);
      }

      //进度条
      else if(type == 7.){
        _color.a *= (1. - step(ext.x, uv0.x)) * (1. - step(ext.y, uv0.y));
      }
      return _color;
  }

  vec4 frag () {
    vec4 o = color;
    if (def < 0.){
      int tt1 = int(t1) - 1;
      if (tt1 >= 0){
        o *= setTexture(tt1, uv0);
      }else{
        o *= normalTexture(cc_spriteTexture, uv0);
      }
      if (t2 > 0.){
        o = setEffect(t2, o);
      }
    } else {
      o *= normalTexture(cc_spriteTexture, uv0);
    }    
    ALPHA_TEST(o);
    return o;
  }
}%
